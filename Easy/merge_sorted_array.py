"""
Жестко хэлпанул - https://www.youtube.com/watch?v=P1Ic85RarKY
 
В видосы он сначала рассказывает как построитть наивное решение
но оно будет работать в O(n) по памяти

НОРМАЛЬНОК РЕШЕНИЕ
После этого он говорил что нужно идти с конца
идем с конца и сраниваем последнее число в nums2 
и последнее число в nums1 (перед нулям)
и ставим в конец именно то которое больше
соответсвенно двигаем основной поинтер (last) влево
и также двигаем влето тот поинтер число из которого мы заюзали
по итогу у нас все получится и цикл дойдет до конца 

самый идеальный вариает есои сначала n дойдет до 0
то есть мы заюзаем все числа из nums2

но может быть и такое что m первым дойдет до 0
в таком случае, мы испольуем не все числа из nums2

и для этого сделаем в конце сделаем цикл
пока n накоенец не дойдет до 0
просто дозаволгняем элементами из nums2
начала массива nums1
"""

def merge(self, nums1: List[int], m: int, nums2: List[int], n: int) -> None:
    last = m + n - 1

    while m > 0 and n > 0:
        if nums1[m - 1] >= nums2[n - 1]:
            nums1[last] = nums1[m - 1]
            m -= 1
        else:
            nums1[last] = nums2[n - 1]
            n -= 1

        last -= 1

    while n > 0:
        nums1[last] = nums2[n - 1]
        n -= 1
        last -= 1

    ### еще можно так вот: ###
    # if n > 0:
    #     for i in range(n):
    #         nums1[i] = nums2[i]

