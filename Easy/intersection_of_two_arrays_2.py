"""
Мое собственное решение

Оно прям ппц какое эффективное!!
O(n) space, O(n) runtime

Алгоритм делится на 3 этапа:
1) Наша задача пройтись по первому массиву (неважно с какого начинать)
и заполнить наш hash map - results
текущее число : Tuple(0, количетсво таких чисел в массиве 1, 0)
2) Теперь также проходимя, но на этот раз по второму массиву
на каждой итерации проверяем если такое число уже есть в results,
если есть то тогда это число есть в массиве 1, и тогда:
текущее число : Tuple(1, количетсво таких чисел в массиве 1, количетсво таких чисел в массиве 2)
3) У нас получился hash map в котором содержатся ТОЛЬКО числа 
которые есть в обоих массивах. И каждому числу принаждлежит
есть ли оно в одном и другом массиве, как раз то что нам нужно (за это отвечает первое 0 или 1)
нам понятное дело нужны только те, у которых единицы
Второе значение - это количетсво таких чисел в первом массиве
Третее значение - это количетсво таких чисел во втором массиве

Для чего мы вообще сохранем это количетсво чиел?
В финалоном ответе нам нужно вывести все числа которые есть в том и другом массиве
Но суть в том что в одном массиве двойки может быть например две,а в другом три
и в ответе должно быть две двойки, так как по две есть и там и там.

Именно поэтому мы выбинраем минимальное количество за choice
и столько (choice) раз добавляем это число в финальный результат.
"""

def intersect(self, nums1: List[int], nums2: List[int]) -> List[int]:
    results = {}

    # 1
    for i in nums1:
        if i in results:
            results[i] = (0, results[i][1] + 1, 0)
        else:
            results[i] = (0, 1, 0)

    # 2
    for i in nums2:
        if i in results:
            results[i] = (1, results[i][1], results[i][2] + 1)
     
    # 3   
    result = []
    for key in results.keys():
        if results[key][0] == 1:
            choice = min(results[key][1], results[key][2])
            for i in range(choice):
                result.append(key)
        
    return result