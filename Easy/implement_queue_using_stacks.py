"""
всего есть два решения, одно более эффективное чем другое
но концепт у них сходий, его можно посмотрет тут
https://www.youtube.com/watch?v=9dTIx0ftUKE (в начеле видоса)
ну кратко, суть в том что мы в прямом смысле используем два стэка
- push() просто добавляет в основной (main) стэк
- pop() делает pop у main стэка пока в нем не останется 1 элемент
и все элементы перекидывает в helper стэк для хранения
а как раз этот последний элемент нам и нужно удалть
так как если представить этот массив в виде очереди
этот элемент вошел первым, то есть должен выйти из очереди первым
удаляем ему и возвращаем все элементы из helper стэка обратно в main стэк
ГОТОВО! ну и возвращаем этот удаленный элемент
- peek() возвращает самый первый в очереди элемент,
а это как раз и есть первый добавленный в main массив элемент
- empty() тут чисто проверяем длинну main стэка

у этого решения время работы всех методов O(1)
кроме метода pop() который работает за O(n)
понятное дело что empty() со своим len
тоже работает за O(n) но это можно легко убрать
добавив переменные-счетчики которые будут следить за длиной
но это нам не нужно в этом задании (лишнее время тратить)
"""

class MyQueue:
    def __init__(self):
        self.main = []
        self.helper = []

    def push(self, x: int) -> None:
        self.main.append(x)
        
    def pop(self) -> int:
        while len(self.main) != 1:
            self.helper.append(self.main.pop())
        value_to_deque = self.main.pop()
        while len(self.helper) != 0:
            self.main.append(self.helper.pop())
        return value_to_deque

    def peek(self) -> int:
        return self.main[0]

    def empty(self) -> bool:
        return len(self.main) == 0

"""
amortized это такой метод когда бывают случаи
когда происходят операции за O(n), а бывают когда за O(1)
и в общем большинство операций происходит на O(1)
поэтому рассматривая например миллион случаев общее будет O(1)

поэтому когда мы добавляем новые элементы
они все идут в main стэк, а вот когда делаем удаление pop()
тогда элементы все также как и в прошлом решении идут в стэк helper
но в этом решении мы перемещаем пряям ВСЕ элементы в helper
и когда это сделали, у нас получился перевернутый стэк main
и мы можемпросто делаеть helper.pop() чтобы удалить
элемент который нам нужно удалить из очереди.

суть в том чтобы все новые ёлементы добававлялись в стэк main
но как только мы хотим сделать pop() тогда создается 
стэк helper просто с перевернутыми значениями из стэка main
и уже все удаления будут происходить из этого стэка helper
пока элементы в нем не закончатся, а когда они закончатся
тогда мы пересоберем заново helper уже с накопившимися
элементами в main
и все будет снова идти по кругу

при получении первого элемента в очереди
просто проверяем заполнен ли стэк helper,
если да, то первым элементов в очереди будет последний
элемент стэка helper. в противном случае это
будет первый элемент в стэке main (так же как и в прошлом решении)
"""

class MyQueue:
    def __init__(self):
        self.main = []
        self.helper = []

    def push(self, x: int) -> None:
        self.main.append(x)
        
    def pop(self) -> int:
        if len(main) == 0:
            while len(self.main) != 0:
                self.helper.append(self.main.pop())
        return self.helper.pop()

    def peek(self) -> int:
        if len(helper) != 0:
            return self.helper[-1]
        else:
            return self.main[0]

    def empty(self) -> bool:
        return len(self.main) == 0 and len(self.helper) == 0

