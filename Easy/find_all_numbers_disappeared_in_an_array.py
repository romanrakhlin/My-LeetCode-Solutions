"""
this problem not easy at all
it can be considered as really tricky medium or simple hard
this is cause of additional task to solve it in O(1) space complexity

окей решать мы ее будем очень просто
так как даны числа от 1 до n это нам подсказка что
будет какаято херня с индксами плюс сказано про O(1) памяти
это пожсказка на то что на придется делать изменения в самом
данном массиве

кароче если вкратце идея в том что каждый элемент это оттдельный индекс который
увеличен на 1 и наша задача пройти по всем цифрам уменьшить их на 1 и начать
ссылкать друг на друга где текущее число - 1 это индекс элемент на который нужно сослаться
и чтобы нам понимать что мы уже сослались на элемент нам нужно это както помечать
мы будем делать число на которое сослались негативным и в итоге элементы на кторые
не сослались и будут стоять на индексах к которым никто не смог подобраться а подобраться
к ним можно было только из элементов со значением - индекс элемента к которому не подобрались + 1
это и есть наши потеряшки поэтому проходимя по массиву еще раз и если видим какоето
положительное чисто просто возвращаем его инедекс + 1
"""
class Solution:
    def findDisappearedNumbers(self, nums: List[int]) -> List[int]:
        result = []
        
        # 1
        for i in range(0, len(nums)):
            index = abs(nums[i]) - 1
            if nums[index] > 0:
                nums[index] = nums[index] * (-1)
        
        # 2
        for i in range(0, len(nums)):
            if nums[i] > 0:
                result.append(i + 1)
        
        return result

        