"""
первое рещене это простое Brute Force решение
но чтобы оно немного эффективное, так как мы можете заметить
что мы не проходимся по массиву два раза
с каждым разом количество итераций во внутреннем цикле еньше и меньше
так как мы сужаем дапазон

к этому легко прийти если просто понять что числа не могут повторяться
(точнее не числа а числа по одному и тому же индексу не могут складываться)
и просто повторяются одни и те же операции.

поэтому мы проходимся вот так как ниже
и просто проверяем являются ли числа в сумме target
если да то возвращаем их индексы.

Time Complexity: O(n^2)
Space Complexity: O(1)
"""

for i in range(0, len(nums)):
    for j in range(i + 1, len(nums)):
        if nums[i] + nums[j] == target:
            return [i, j]

"""
https://www.youtube.com/watch?v=BoHO04xVeU0&t=508s

вся суть в расчете complement
это такое число, например, если 2 + 7 = 9
то 9 - 7 = 2 и 9 - 2 = 7
если у нас есть массив [2, 7, 8, 4]
и из него составить массив из complements -> [7, 2, 1, 5]
то можно видеть что в двух массивах эти числа присутствуют,
именно они (точнее их индексы в первоначальном массиве)
и являются результатом

но если мы будем составлять такие два массива,
числа же могут повторяться, и это будет неэффективно
проходить два массива и искать O(n^2)
а както хранить идексы чтобы потом быстро отыскать повторяющие числа
тоже не вариант, так как есл например заданный массив = [3, 3, 4], t = 6
то в словаре два числа просто схлопнуться в одно

и чтобы все было максимаьлно эффективно и просто
нужно сделать все в один проход массива.
алгоритм такой:

1) создаем hash_map, где:
key - само текущее число
value - индекс этого числа

2) проходимся по массиву (ОДИН РАЗ!!)
и каждую итерацию нам нужно заполнять наш hash_map
на этой же итерации (перед добавлением в hash_map)
высчитываем complement и делаем проверку:
находится ли compliment (как число) в hash_map
это будет означать что мы уже проходилис до
этого по числу, которое равно этого complement,
то есть прибавив текущее число и то которое равно complement
У НАС КАК РАЗ И ПОЛУЧИТСЯ TARGET!!!!
поэтому если complement уже лежит в hash_map
возвращаем как ответ сначала идекс того числа по которому
мы проходили (которое равно complement) а потом индекс текущего числа

Плюс такого подхода это то что мы идем с начала массива по конец,
и рано или поздно найдутся первые два таике числа которые будет в сумме
давать target, и будут являться ответами!!

Time Complexity: O(n)
Space Complexity: O(n)
"""

def twoSum(self, nums: List[int], target: int) -> List[int]:
    hash_map = {}
    for i in range(0, len(nums)):
        complement = target - nums[i]
        if complement in hash_map:
            return [hash_map[complement], i]
        hash_map[nums[i]] = i

